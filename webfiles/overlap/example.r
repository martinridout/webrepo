##====================================================================
## This program illstrates how to do basic overlap calculations, using
## Tiger and Muntjac as an example.
##
## Refer to the following paper for details of the methodology:
## Ridout, M.S. and Linkie, M. (2009) 
## Estimating overlap of daily activity patterns from camera trap data
## Journal of Agricultural, Biological and Environmental Statistics,
## 14, 322-337.
##====================================================================

    ##--------------
    ## Read data etc
    ##--------------
source("setup.r")

    ##-------------------------------
    ## Set up for two figures on page
    ##-------------------------------
par(mfrow=c(2,1))

    ##----------------------------------------------------
    ## Basic kernel density estimation. You need to choose
    ## values for the parameters K and c discussed in the
    ## paper by Ridout & Linkie.
    ##
    ## These commands do the estimation and plot the 
    ## estimates (tiger is the dashed line). You can ignore 
    ## the warning messages that are generated by the 
    ## circular package.
    ##----------------------------------------------------
K = 3
c = 1
kernel.tiger = kplot( tiger, K, c)
kernel.muntjac = kplot( muntjac, K, c)

    ##--------------------------------------------------------------
    ## Note the /24 needed on the y-axis, to get the correct scaling
    ##--------------------------------------------------------------
plot(kernel.muntjac$x, kernel.muntjac$y/24, type="l", xaxt="n", 
     xlab="Tiger (dashed), Muntjac (solid)", ylab="Activity density")
lines(kernel.tiger$x, kernel.tiger$y/24, lty="dashed", col="red") 
axis(1, at=c(0,0.25,0.5,0.75,1), labels=c("0:00", "6:00", "12:00", "18:00", "24:00"))

    ##----------------------------------------------------------
    ##--------------------------------
    ## Calculate the ovlerap estimates. Produces the estimates
    ## Delta_1_hat ... Delta_5_hat. Note that for circular data
    ## (like time of day), Delta_3_hat is not defined (hence the 
    ## value is given as NA, and that Delta_1_hat = Delta_2_hat.
    ## So there are only 3 distinct estimates, Delta_1_hat,
    ## Delta_4_hat and Delta_5_hat (and these are the only ones
    ## that we print here. See the Ridout & Linkie 
    ## paper for recommendations about which one to use.
    ##----------------------------------------------------------
kernel.overlap = ovlest.robust2( tiger, muntjac, K, c)
cat("\nEstimates of overlap based on kernel estimates of density\n")
print(kernel.overlap[c(1,4,5)])

    ##-----------------------------------------------------------
    ## Alternatively, we can fit trigonometric sum distributions.
    ## This is much slower, because of the need to do lots of
    ## fits. The second term
    ##    nrep = c(10,10,10,10)
    ## means that models of order 1, 2, 3, 4 will be fitted
    ## with 10 starting points for each (because of possible
    ## problems with multiple optima). The best model is
    ## selected automatically by AIC.
    ##-----------------------------------------------------------
u = seq(0,1, length.out=512)
tsd.tiger = fit.trigseries(tiger, nrep=c(10,10,10,10))
tsd.muntjac = fit.trigseries(muntjac, nrep=c(10,10,10,10))

    ##--------------------------------------------------------------
    ## Note that the conversion to 24-hour period is different here,
    ## need to MULTIPLY by 24 to get the correct scaling
    ##--------------------------------------------------------------
plot(u, tsd.muntjac*24, type="l", xaxt="n",
     xlab="Tiger (dashed), Muntjac (solid)", ylab="Activity density")
lines(u, tsd.tiger*24, lty="dashed", col="red") 
axis(1, at=c(0,0.25,0.5,0.75,1), labels=c("0:00", "6:00", "12:00", "18:00", "24:00"))

    ##---------------------------------------------------------------
    ## Here is a function to calculate overlap based on trigonometric
    ## sum distributions. 
    ##---------------------------------------------------------------
grid = seq(0, 2*pi, length.out=512)
trig.overlap = ovlcalc.circular(grid, tsd.tiger, tsd.muntjac, tiger, muntjac)
cat("\nEstimates of overlap (1,4,5) based on trigonometric sum estimates of density\n")
print(trig.overlap[c(1,4,5)])

    ##-----------------------------------------------------
    ## Bootstrap based confidence limits (95%)
    ## nboot = number of bootstrap samples. Set to a fairly
    ##         small value here, for speed. Papers used a 
    ##         value of nboot = 500
    ##-----------------------------------------------------
nboot = 50
boot.sample = bootstrap.ovl(tiger, muntjac, K, c, nboot)

    ##-----------------------------------------
    ## Print the individual bootstrap estimates
    ##-----------------------------------------
print(boot.sample)

    ##--------------------------------------------
    ## Calculate and display the confidence limits
    ##--------------------------------------------
lower = numeric(3)
upper = numeric(3)
lower.percentile = 0.025
upper.percentile = 0.975
for (j in 1: 3) {
    lower[j] = quantile(boot.sample[,j], lower.percentile)
    upper[j] = quantile(boot.sample[,j], upper.percentile)
}
cat("\nLower confidence limit for estimates 1, 4 and 5\n")
print(lower)
cat("\nUpper confidence limit for estimates 1, 4 and 5\n")
print(upper)

   ##----------------------------------------------------
   ## Note that we haven't calculated bootstrap intervals
   ## for overlap estimates based on trigonometric sum
   ## distributions. This can be done (see the function
   ## bootstrap.trig in ovlcode.r, or the function 
   ## bootstrap.both, which does both kernel and trig
   ## sum-based estimates at once. However, bootstrap
   ## calculations that involve fitting trigonometric
   ## sum distributions are VERY slow. Since they give
   ## similar results, in our experience, to using
   ## kernel density estimates, they may not often be
   ## needed.
   ##----------------------------------------------------
